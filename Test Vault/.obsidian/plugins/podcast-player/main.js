/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var x=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var $=Object.prototype.hasOwnProperty;var V=(d,t)=>{for(var e in t)x(d,e,{get:t[e],enumerable:!0})},L=(d,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of O(t))!$.call(d,i)&&i!==e&&x(d,i,{get:()=>t[i],enumerable:!(s=R(t,i))||s.enumerable});return d};var U=d=>L(x({},"__esModule",{value:!0}),d);var J={};V(J,{default:()=>v});module.exports=U(J);var h=require("obsidian");var p={dataFolderPath:".obsidian/plugins/podcast-player/data",defaultPlaybackSettings:{volume:1,playbackSpeed:1,skipIntroSeconds:0,skipOutroSeconds:0},autoDownload:!1,maxCacheEpisodes:50,feedUpdateInterval:60,enableNotifications:!0};var u=require("obsidian");var E=class d{constructor(){this.logLevel=1;this.prefix="[Podcast Player]"}static getInstance(){return d.instance||(d.instance=new d),d.instance}setLogLevel(t){this.logLevel=t}getLogLevel(){return this.logLevel}debug(t,...e){this.logLevel<=0&&console.debug(`${this.prefix} [DEBUG]`,t,...e)}info(t,...e){this.logLevel<=1&&console.info(`${this.prefix} [INFO]`,t,...e)}warn(t,...e){this.logLevel<=2&&console.warn(`${this.prefix} [WARN]`,t,...e)}error(t,e,...s){this.logLevel<=3&&(e instanceof Error?console.error(`${this.prefix} [ERROR]`,t,e.message,e.stack,...s):console.error(`${this.prefix} [ERROR]`,t,e,...s))}methodEntry(t,e,...s){this.debug(`${t}.${e}() called`,...s)}methodExit(t,e,s){this.debug(`${t}.${e}() completed`,s)}},a=E.getInstance();var j=require("obsidian"),I=class extends Error{constructor(e,s){super(e);this.code=s;this.name="PodcastPlayerError"}};var n=class extends I{constructor(e,s){super(e,"STORAGE_ERROR");this.path=s;this.name="StorageError"}};function T(d,t){try{return JSON.parse(d)}catch(e){return a.warn("Failed to parse JSON",e),t}}var m=class{constructor(t,e){this.vault=t,this.basePath=(0,u.normalizePath)(e),this.structure=this.buildStructure()}buildStructure(){return{root:this.basePath,subscriptions:(0,u.normalizePath)(`${this.basePath}/subscriptions`),progress:(0,u.normalizePath)(`${this.basePath}/progress`),playlists:(0,u.normalizePath)(`${this.basePath}/playlists`),queues:(0,u.normalizePath)(`${this.basePath}/queues`),cache:(0,u.normalizePath)(`${this.basePath}/cache`),cacheFeed:(0,u.normalizePath)(`${this.basePath}/cache/feeds`),cacheImages:(0,u.normalizePath)(`${this.basePath}/cache/images`),backups:(0,u.normalizePath)(`${this.basePath}/backups`)}}getStructure(){return{...this.structure}}getBasePath(){return this.basePath}updateBasePath(t){this.basePath=(0,u.normalizePath)(t),this.structure=this.buildStructure()}async ensureDirectories(){a.info("Ensuring data directories exist",this.basePath);try{let t=this.vault.adapter;await t.exists(this.basePath)||(a.info("Creating base directory",this.basePath),await t.mkdir(this.basePath));let e=[this.structure.subscriptions,this.structure.progress,this.structure.playlists,this.structure.queues,this.structure.cache,this.structure.cacheFeed,this.structure.cacheImages,this.structure.backups];for(let s of e)await t.exists(s)||(a.debug("Creating directory",s),await t.mkdir(s));a.info("Data directories ready")}catch(t){throw a.error("Failed to create data directories",t),new n("Failed to create data directories",this.basePath)}}getFilePath(t,e){let s=this.structure[t];return(0,u.normalizePath)(`${s}/${e}`)}async directoryExists(t){try{return await this.vault.adapter.exists(t)}catch(e){return a.error("Failed to check directory existence",e),!1}}async fileExists(t){try{return await this.vault.adapter.exists(t)}catch(e){return a.error("Failed to check file existence",e),!1}}async listFiles(t){let e=this.structure[t];try{let s=this.vault.adapter;return await s.exists(e)?(await s.list(e)).files:[]}catch(s){throw a.error("Failed to list files",s),new n(`Failed to list files in ${e}`,e)}}async deleteFile(t){try{await this.vault.adapter.remove(t),a.debug("Deleted file",t)}catch(e){throw a.error("Failed to delete file",e),new n(`Failed to delete file ${t}`,t)}}async createBackup(t,e){try{let s=await this.vault.adapter.read(t),i=new Date().toISOString().replace(/[:.]/g,"-"),r=e||`backup-${i}.json`,o=this.getFilePath("backups",r);return await this.vault.adapter.write(o,s),a.info("Created backup",o),o}catch(s){throw a.error("Failed to create backup",s),new n(`Failed to create backup of ${t}`,t)}}async cleanupOldBackups(t=5){try{let e=await this.listFiles("backups");if(e.length<=t)return;let s=await Promise.all(e.map(async r=>{let o=await this.vault.adapter.stat(r);return{file:r,mtime:(o==null?void 0:o.mtime)||0}}));s.sort((r,o)=>o.mtime-r.mtime);let i=s.slice(t);for(let{file:r}of i)await this.deleteFile(r),a.debug("Deleted old backup",r);a.info(`Cleaned up ${i.length} old backups`)}catch(e){a.error("Failed to cleanup old backups",e)}}async getDirectorySize(t){try{let e=await this.listFiles(t),s=0;for(let i of e){let r=await this.vault.adapter.stat(i);s+=(r==null?void 0:r.size)||0}return s}catch(e){return a.error("Failed to get directory size",e),0}}};var A=require("obsidian");var w=class{constructor(t,e,s="json"){this.vault=t,this.pathManager=e,this.format=s}async readJson(t,e){try{let s=this.vault.adapter;if(!await s.exists(t))return a.debug("File does not exist, returning fallback",t),e;let i=await s.read(t),r=T(i,e);return a.debug("Read JSON file",t),r}catch(s){throw a.error("Failed to read JSON file",s),new n(`Failed to read file ${t}`,t)}}async writeJson(t,e,s=!0){try{let i=this.vault.adapter;if(s&&await i.exists(t))try{await this.pathManager.createBackup(t)}catch(o){a.warn("Failed to create backup, continuing",o)}let r=JSON.stringify(e,null,2);await i.write(t,r),a.debug("Wrote JSON file",t)}catch(i){throw a.error("Failed to write JSON file",i),new n(`Failed to write file ${t}`,t)}}async deleteFile(t){try{await this.vault.adapter.remove(t),a.debug("Deleted file",t)}catch(e){throw a.error("Failed to delete file",e),new n(`Failed to delete file ${t}`,t)}}async fileExists(t){try{return await this.vault.adapter.exists(t)}catch(e){return a.error("Failed to check file existence",e),!1}}async listFiles(t){try{let e=this.vault.adapter;return await e.exists(t)?(await e.list(t)).files:[]}catch(e){throw a.error("Failed to list files",e),new n(`Failed to list files in ${t}`,t)}}},g=class extends w{constructor(t,e,s,i="json"){super(t,e,i),this.filePath=(0,A.normalizePath)(s)}async load(){a.methodEntry("SingleFileStore","load",this.filePath);let t=await this.readJson(this.filePath,this.getDefaultValue());return this.validate(t)?(a.methodExit("SingleFileStore","load"),t):(a.warn("Data validation failed, using default value",this.filePath),this.getDefaultValue())}async save(t){if(a.methodEntry("SingleFileStore","save",this.filePath),!this.validate(t))throw new n("Data validation failed",this.filePath);await this.writeJson(this.filePath,t),a.methodExit("SingleFileStore","save")}async clear(){a.methodEntry("SingleFileStore","clear",this.filePath);let t=this.getDefaultValue();await this.save(t),a.methodExit("SingleFileStore","clear")}async delete(){await this.fileExists(this.filePath)&&await this.deleteFile(this.filePath)}};var f=class f extends g{constructor(t,e){let s=e.getFilePath("subscriptions","subscriptions.json");super(t,e,s)}validate(t){if(!t||typeof t!="object")return a.warn("Invalid subscription data: not an object"),!1;if(!Array.isArray(t.podcasts))return a.warn("Invalid subscription data: podcasts is not an array"),!1;if(typeof t.version!="number")return a.warn("Invalid subscription data: version is not a number"),!1;for(let e of t.podcasts)if(!this.validatePodcast(e))return a.warn("Invalid podcast in subscription data",e),!1;return!0}validatePodcast(t){if(!t||typeof t!="object")return!1;let e=["id","title","feedUrl","subscribedAt"];for(let s of e)if(!(s in t))return a.warn(`Missing required field in podcast: ${s}`),!1;return!0}getDefaultValue(){return{podcasts:[],version:f.CURRENT_VERSION}}async getAllPodcasts(){a.methodEntry("SubscriptionStore","getAllPodcasts");let t=await this.load();return a.methodExit("SubscriptionStore","getAllPodcasts"),t.podcasts}async getPodcast(t){a.methodEntry("SubscriptionStore","getPodcast",t);let s=(await this.load()).podcasts.find(i=>i.id===t)||null;return a.methodExit("SubscriptionStore","getPodcast"),s}async getPodcastByFeedUrl(t){a.methodEntry("SubscriptionStore","getPodcastByFeedUrl",t);let s=(await this.load()).podcasts.find(i=>i.feedUrl===t)||null;return a.methodExit("SubscriptionStore","getPodcastByFeedUrl"),s}async addPodcast(t){if(a.methodEntry("SubscriptionStore","addPodcast",t.id),!this.validatePodcast(t))throw new n("Invalid podcast data",this.filePath);let e=await this.load(),s=e.podcasts.findIndex(i=>i.id===t.id);s!==-1?(a.warn("Podcast already exists, updating instead",t.id),e.podcasts[s]=t):e.podcasts.push(t),await this.save(e),a.methodExit("SubscriptionStore","addPodcast")}async updatePodcast(t){if(a.methodEntry("SubscriptionStore","updatePodcast",t.id),!this.validatePodcast(t))throw new n("Invalid podcast data",this.filePath);let e=await this.load(),s=e.podcasts.findIndex(i=>i.id===t.id);if(s===-1)throw new n(`Podcast not found: ${t.id}`,this.filePath);e.podcasts[s]=t,await this.save(e),a.methodExit("SubscriptionStore","updatePodcast")}async removePodcast(t){a.methodEntry("SubscriptionStore","removePodcast",t);let e=await this.load(),s=e.podcasts.findIndex(i=>i.id===t);if(s===-1){a.warn("Podcast not found, nothing to remove",t);return}e.podcasts.splice(s,1),await this.save(e),a.methodExit("SubscriptionStore","removePodcast")}async isSubscribed(t){return(await this.load()).podcasts.some(s=>s.id===t)}async isSubscribedByFeedUrl(t){return(await this.load()).podcasts.some(s=>s.feedUrl===t)}async getSubscriptionCount(){return(await this.load()).podcasts.length}async updatePodcastEpisodes(t,e){a.methodEntry("SubscriptionStore","updatePodcastEpisodes",t);let s=await this.load(),i=s.podcasts.find(r=>r.id===t);if(!i)throw new n(`Podcast not found: ${t}`,this.filePath);i.episodes=e,i.lastFetchedAt=new Date,await this.save(s),a.methodExit("SubscriptionStore","updatePodcastEpisodes")}async updatePodcastSettings(t,e){a.methodEntry("SubscriptionStore","updatePodcastSettings",t);let s=await this.load(),i=s.podcasts.find(r=>r.id===t);if(!i)throw new n(`Podcast not found: ${t}`,this.filePath);i.settings=e,await this.save(s),a.methodExit("SubscriptionStore","updatePodcastSettings")}async getPodcastsNeedingUpdate(t){let e=await this.load(),s=Date.now();return e.podcasts.filter(i=>{if(!i.lastFetchedAt)return!0;let r=new Date(i.lastFetchedAt).getTime();return s-r>=t})}async searchPodcasts(t){let e=await this.load(),s=t.toLowerCase();return e.podcasts.filter(i=>{var l;let r=i.title.toLowerCase().includes(s),o=(l=i.author)==null?void 0:l.toLowerCase().includes(s);return r||o})}async exportSubscriptions(){a.methodEntry("SubscriptionStore","exportSubscriptions");let t=await this.load();return a.methodExit("SubscriptionStore","exportSubscriptions"),t}async importSubscriptions(t,e=!1){if(a.methodEntry("SubscriptionStore","importSubscriptions",`replace=${e}`),!this.validate(t))throw new n("Invalid import data",this.filePath);if(e)await this.save(t);else{let i=[...(await this.load()).podcasts];for(let r of t.podcasts){let o=i.findIndex(l=>l.id===r.id);o!==-1?i[o]=r:i.push(r)}await this.save({podcasts:i,version:f.CURRENT_VERSION})}a.methodExit("SubscriptionStore","importSubscriptions")}};f.CURRENT_VERSION=1;var F=f;function D(d,t,e=30){return t<=0?!1:t-d<=e}var P=class P extends g{constructor(t,e){let s=e.getFilePath("progress","progress.json");super(t,e,s)}validate(t){if(!t||typeof t!="object")return a.warn("Invalid progress data: not an object"),!1;if(!Array.isArray(t.progress))return a.warn("Invalid progress data: progress is not an array"),!1;if(typeof t.version!="number")return a.warn("Invalid progress data: version is not a number"),!1;for(let e of t.progress)if(!this.validateProgress(e))return a.warn("Invalid progress entry in data",e),!1;return!0}validateProgress(t){if(!t||typeof t!="object")return!1;let e=["episodeId","podcastId","position","duration","lastPlayedAt"];for(let s of e)if(!(s in t))return a.warn(`Missing required field in progress: ${s}`),!1;return!(typeof t.position!="number"||t.position<0||typeof t.duration!="number"||t.duration<0||typeof t.completed!="boolean")}getDefaultValue(){return{progress:[],version:P.CURRENT_VERSION}}async getProgress(t){a.methodEntry("ProgressStore","getProgress",t);let s=(await this.load()).progress.find(i=>i.episodeId===t)||null;return a.methodExit("ProgressStore","getProgress"),s}async getPodcastProgress(t){a.methodEntry("ProgressStore","getPodcastProgress",t);let s=(await this.load()).progress.filter(i=>i.podcastId===t);return a.methodExit("ProgressStore","getPodcastProgress"),s}async getAllProgress(){a.methodEntry("ProgressStore","getAllProgress");let t=await this.load();return a.methodExit("ProgressStore","getAllProgress"),t.progress}async updateProgress(t){if(a.methodEntry("ProgressStore","updateProgress",t.episodeId),!this.validateProgress(t))throw new n("Invalid progress data",this.filePath);let e=await this.load(),s=e.progress.findIndex(i=>i.episodeId===t.episodeId);t.completed=D(t.position,t.duration),s!==-1?e.progress[s]=t:e.progress.push(t),await this.save(e),a.methodExit("ProgressStore","updateProgress")}async updatePosition(t,e,s,i){a.methodEntry("ProgressStore","updatePosition",t);let r=await this.getProgress(t),o={episodeId:t,podcastId:e,position:s,duration:i,lastPlayedAt:new Date,completed:D(s,i)};await this.updateProgress(o),a.methodExit("ProgressStore","updatePosition")}async markCompleted(t,e,s){a.methodEntry("ProgressStore","markCompleted",t);let i={episodeId:t,podcastId:e,position:s,duration:s,lastPlayedAt:new Date,completed:!0};await this.updateProgress(i),a.methodExit("ProgressStore","markCompleted")}async resetProgress(t){a.methodEntry("ProgressStore","resetProgress",t);let e=await this.load(),s=e.progress.findIndex(i=>i.episodeId===t);s!==-1&&(e.progress.splice(s,1),await this.save(e)),a.methodExit("ProgressStore","resetProgress")}async removeProgress(t){a.methodEntry("ProgressStore","removeProgress",t);let e=await this.load(),s=e.progress.findIndex(i=>i.episodeId===t);s!==-1&&(e.progress.splice(s,1),await this.save(e)),a.methodExit("ProgressStore","removeProgress")}async removePodcastProgress(t){a.methodEntry("ProgressStore","removePodcastProgress",t);let e=await this.load();e.progress=e.progress.filter(s=>s.podcastId!==t),await this.save(e),a.methodExit("ProgressStore","removePodcastProgress")}async getInProgressEpisodes(){return(await this.load()).progress.filter(e=>!e.completed&&e.position>0)}async getCompletedEpisodes(){return(await this.load()).progress.filter(e=>e.completed)}async getRecentlyPlayed(t=10){return[...(await this.load()).progress].sort((i,r)=>{let o=new Date(i.lastPlayedAt).getTime();return new Date(r.lastPlayedAt).getTime()-o}).slice(0,t)}async getCompletionPercentage(t){let e=await this.getProgress(t);return!e||e.duration<=0?0:Math.min(100,Math.max(0,e.position/e.duration*100))}async getTotalListeningTime(){return(await this.load()).progress.reduce((e,s)=>e+s.position,0)}async getPodcastStatistics(t){let e=await this.getPodcastProgress(t);return{totalEpisodes:e.length,completedEpisodes:e.filter(s=>s.completed).length,inProgressEpisodes:e.filter(s=>!s.completed&&s.position>0).length,totalListeningTime:e.reduce((s,i)=>s+i.position,0)}}async cleanupOldProgress(t=100){a.methodEntry("ProgressStore","cleanupOldProgress",`keepRecentCount=${t}`);let e=await this.load(),s=[...e.progress].sort((i,r)=>{let o=new Date(i.lastPlayedAt).getTime();return new Date(r.lastPlayedAt).getTime()-o});e.progress=s.slice(0,t),await this.save(e),a.methodExit("ProgressStore","cleanupOldProgress")}async exportProgress(){a.methodEntry("ProgressStore","exportProgress");let t=await this.load();return a.methodExit("ProgressStore","exportProgress"),t}async importProgress(t,e=!1){if(a.methodEntry("ProgressStore","importProgress",`replace=${e}`),!this.validate(t))throw new n("Invalid import data",this.filePath);if(e)await this.save(t);else{let i=[...(await this.load()).progress];for(let r of t.progress){let o=i.findIndex(l=>l.episodeId===r.episodeId);if(o!==-1){let l=new Date(i[o].lastPlayedAt).getTime();new Date(r.lastPlayedAt).getTime()>l&&(i[o]=r)}else i.push(r)}await this.save({progress:i,version:P.CURRENT_VERSION})}a.methodExit("ProgressStore","importProgress")}};P.CURRENT_VERSION=1;var C=P;var N=require("obsidian");var y=class extends g{constructor(t,e){let s=e.getFilePath("root","settings.json");super(t,e,s)}validate(t){if(!t||typeof t!="object")return a.warn("Invalid settings data: not an object"),!1;if(typeof t.dataFolderPath!="string")return a.warn("Invalid settings: dataFolderPath is not a string"),!1;if(!t.defaultPlaybackSettings||typeof t.defaultPlaybackSettings!="object")return a.warn("Invalid settings: defaultPlaybackSettings is not an object"),!1;let e=t.defaultPlaybackSettings;return typeof e.volume!="number"||typeof e.playbackSpeed!="number"||typeof e.skipIntroSeconds!="number"?(a.warn("Invalid settings: defaultPlaybackSettings has invalid fields"),!1):typeof t.autoDownload!="boolean"?(a.warn("Invalid settings: autoDownload is not a boolean"),!1):typeof t.enableNotifications!="boolean"?(a.warn("Invalid settings: enableNotifications is not a boolean"),!1):typeof t.maxCacheEpisodes!="number"||t.maxCacheEpisodes<0?(a.warn("Invalid settings: maxCacheEpisodes is invalid"),!1):typeof t.feedUpdateInterval!="number"||t.feedUpdateInterval<0?(a.warn("Invalid settings: feedUpdateInterval is invalid"),!1):!0}getDefaultValue(){return{...p}}async getSettings(){a.methodEntry("SettingsStore","getSettings");let t=await this.load();return a.methodExit("SettingsStore","getSettings"),t}async updateSettings(t){a.methodEntry("SettingsStore","updateSettings"),await this.save(t),a.methodExit("SettingsStore","updateSettings")}async updateSetting(t,e){a.methodEntry("SettingsStore","updateSetting",t);let s=await this.load();s[t]=e,await this.save(s),a.methodExit("SettingsStore","updateSetting")}async getSetting(t){return(await this.load())[t]}async updateDataFolderPath(t){a.methodEntry("SettingsStore","updateDataFolderPath",t),await this.updateSetting("dataFolderPath",(0,N.normalizePath)(t)),a.methodExit("SettingsStore","updateDataFolderPath")}async updateDefaultVolume(t){a.methodEntry("SettingsStore","updateDefaultVolume",t);let e=await this.load();e.defaultPlaybackSettings.volume=Math.max(0,Math.min(1,t)),await this.save(e),a.methodExit("SettingsStore","updateDefaultVolume")}async updateDefaultPlaybackSpeed(t){a.methodEntry("SettingsStore","updateDefaultPlaybackSpeed",t);let e=await this.load();e.defaultPlaybackSettings.playbackSpeed=Math.max(.5,Math.min(3,t)),await this.save(e),a.methodExit("SettingsStore","updateDefaultPlaybackSpeed")}async updateDefaultSkipIntro(t){a.methodEntry("SettingsStore","updateDefaultSkipIntro",t);let e=await this.load();e.defaultPlaybackSettings.skipIntroSeconds=Math.max(0,t),await this.save(e),a.methodExit("SettingsStore","updateDefaultSkipIntro")}async updateDefaultSkipOutro(t){a.methodEntry("SettingsStore","updateDefaultSkipOutro",t);let e=await this.load();e.defaultPlaybackSettings.skipOutroSeconds=Math.max(0,t),await this.save(e),a.methodExit("SettingsStore","updateDefaultSkipOutro")}async updateAutoDownload(t){a.methodEntry("SettingsStore","updateAutoDownload",t),await this.updateSetting("autoDownload",t),a.methodExit("SettingsStore","updateAutoDownload")}async updateMaxCacheEpisodes(t){a.methodEntry("SettingsStore","updateMaxCacheEpisodes",t),await this.updateSetting("maxCacheEpisodes",Math.max(0,t)),a.methodExit("SettingsStore","updateMaxCacheEpisodes")}async updateFeedUpdateInterval(t){a.methodEntry("SettingsStore","updateFeedUpdateInterval",t),await this.updateSetting("feedUpdateInterval",Math.max(0,t)),a.methodExit("SettingsStore","updateFeedUpdateInterval")}async updateNotifications(t){a.methodEntry("SettingsStore","updateNotifications",t),await this.updateSetting("enableNotifications",t),a.methodExit("SettingsStore","updateNotifications")}async resetToDefaults(){a.methodEntry("SettingsStore","resetToDefaults"),await this.save(this.getDefaultValue()),a.methodExit("SettingsStore","resetToDefaults")}async exportSettings(){a.methodEntry("SettingsStore","exportSettings");let t=await this.load();return a.methodExit("SettingsStore","exportSettings"),t}async importSettings(t){if(a.methodEntry("SettingsStore","importSettings"),!this.validate(t))throw new n("Invalid import settings",this.filePath);await this.save(t),a.methodExit("SettingsStore","importSettings")}async loadWithMigration(){a.methodEntry("SettingsStore","loadWithMigration");let t=await this.load(),e={...this.getDefaultValue(),...t,defaultPlaybackSettings:{...p.defaultPlaybackSettings,...t.defaultPlaybackSettings}};return JSON.stringify(t)!==JSON.stringify(e)&&(a.info("Migrating settings to current version"),await this.save(e)),a.methodExit("SettingsStore","loadWithMigration"),e}};var b=class b{constructor(t,e){this.vault=t,this.pathManager=e,this.indexFilePath=e.getFilePath("cache","image-index.json")}async loadIndex(){try{let t=this.vault.adapter;if(!await t.exists(this.indexFilePath))return this.getDefaultIndex();let e=await t.read(this.indexFilePath),s=JSON.parse(e);return this.validateIndex(s)?s:(a.warn("Invalid image cache index, using default"),this.getDefaultIndex())}catch(t){return a.error("Failed to load image cache index",t),this.getDefaultIndex()}}async saveIndex(t){try{let e=JSON.stringify(t,null,2);await this.vault.adapter.write(this.indexFilePath,e)}catch(e){throw a.error("Failed to save image cache index",e),new n("Failed to save image cache index",this.indexFilePath)}}validateIndex(t){return!(!t||typeof t!="object"||!Array.isArray(t.images)||typeof t.version!="number")}getDefaultIndex(){return{images:[],version:b.CURRENT_VERSION}}getImageCacheFilename(t){let e="jpg";try{let o=new URL(t).pathname.match(/\.([a-zA-Z0-9]+)$/);o&&(e=o[1].toLowerCase())}catch(i){}let s=0;for(let i=0;i<t.length;i++){let r=t.charCodeAt(i);s=(s<<5)-s+r,s=s&s}return`image-${Math.abs(s).toString(36)}.${e}`}async getCachedImage(t){a.methodEntry("ImageCacheStore","getCachedImage",t);let s=(await this.loadIndex()).images.find(r=>r.imageUrl===t);return s?await this.vault.adapter.exists(s.localPath)?(a.methodExit("ImageCacheStore","getCachedImage"),s.localPath):(a.warn("Cached image file not found",s.localPath),await this.removeCachedImage(t),a.methodExit("ImageCacheStore","getCachedImage","file missing"),null):(a.methodExit("ImageCacheStore","getCachedImage","not found"),null)}async cacheImage(t,e){a.methodEntry("ImageCacheStore","cacheImage",t);let s=this.getImageCacheFilename(t),i=this.pathManager.getFilePath("cacheImages",s);await this.vault.adapter.writeBinary(i,e);let r=await this.loadIndex();r.images=r.images.filter(l=>l.imageUrl!==t);let o={imageUrl:t,localPath:i,cachedAt:new Date,size:e.byteLength};return r.images.push(o),await this.saveIndex(r),a.methodExit("ImageCacheStore","cacheImage"),i}async removeCachedImage(t){a.methodEntry("ImageCacheStore","removeCachedImage",t);let e=await this.loadIndex(),s=e.images.find(i=>i.imageUrl===t);if(s){try{await this.vault.adapter.remove(s.localPath)}catch(i){a.warn("Failed to delete cached image file",i)}e.images=e.images.filter(i=>i.imageUrl!==t),await this.saveIndex(e)}a.methodExit("ImageCacheStore","removeCachedImage")}async clearAll(){a.methodEntry("ImageCacheStore","clearAll");let t=await this.loadIndex();for(let e of t.images)try{await this.vault.adapter.remove(e.localPath)}catch(s){a.warn(`Failed to delete cached image: ${e.localPath}`,s)}await this.saveIndex(this.getDefaultIndex()),a.methodExit("ImageCacheStore","clearAll")}async getCacheStats(){let t=await this.loadIndex(),e=t.images.reduce((s,i)=>s+i.size,0);return{totalImages:t.images.length,totalSize:e}}async cleanupOldImages(t=100){a.methodEntry("ImageCacheStore","cleanupOldImages",`keepCount=${t}`);let e=await this.loadIndex();if(e.images.length<=t){a.methodExit("ImageCacheStore","cleanupOldImages","nothing to cleanup");return}let s=[...e.images].sort((r,o)=>{let l=new Date(r.cachedAt).getTime();return new Date(o.cachedAt).getTime()-l}),i=s.slice(t);for(let r of i)try{await this.vault.adapter.remove(r.localPath)}catch(o){a.warn(`Failed to delete old image: ${r.localPath}`,o)}e.images=s.slice(0,t),await this.saveIndex(e),a.info(`Cleaned up ${i.length} old cached images`),a.methodExit("ImageCacheStore","cleanupOldImages")}};b.CURRENT_VERSION=1;var k=b;var c=require("obsidian"),S=class extends c.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}display(){let{containerEl:t}=this;t.empty(),this.loadSettings(),t.createEl("h2",{text:"Podcast Player Settings"}),this.addStorageSection(t),this.addPlaybackSection(t),this.addCacheSection(t),this.addSyncSection(t),this.addNotificationSection(t),this.addAdvancedSection(t)}async loadSettings(){this.settings=this.plugin.settings}async saveSettings(){await this.plugin.saveSettings()}addStorageSection(t){t.createEl("h3",{text:"Data Storage"}),new c.Setting(t).setName("Data folder path").setDesc("Folder where podcast data will be stored (relative to vault root)").addText(e=>e.setPlaceholder(".obsidian/plugins/podcast-player/data").setValue(this.settings.dataFolderPath).onChange(async s=>{this.settings.dataFolderPath=s,await this.saveSettings()}))}addPlaybackSection(t){t.createEl("h3",{text:"Default Playback Settings"}),t.createEl("p",{text:"These settings apply to all podcasts by default. Individual podcasts can override these.",cls:"setting-item-description"}),new c.Setting(t).setName("Default volume").setDesc("Default playback volume (0.0 to 1.0)").addSlider(e=>e.setLimits(0,100,5).setValue(this.settings.defaultPlaybackSettings.volume*100).setDynamicTooltip().onChange(async s=>{this.settings.defaultPlaybackSettings.volume=s/100,await this.saveSettings()})),new c.Setting(t).setName("Default playback speed").setDesc("Default playback speed (0.5x to 3.0x)").addSlider(e=>e.setLimits(50,300,5).setValue(this.settings.defaultPlaybackSettings.playbackSpeed*100).setDynamicTooltip().onChange(async s=>{this.settings.defaultPlaybackSettings.playbackSpeed=s/100,await this.saveSettings()})),new c.Setting(t).setName("Skip intro seconds").setDesc("Number of seconds to skip at the beginning of each episode").addText(e=>e.setPlaceholder("0").setValue(String(this.settings.defaultPlaybackSettings.skipIntroSeconds)).onChange(async s=>{let i=parseInt(s,10);!isNaN(i)&&i>=0&&(this.settings.defaultPlaybackSettings.skipIntroSeconds=i,await this.saveSettings())})),new c.Setting(t).setName("Skip outro seconds").setDesc("Number of seconds to skip at the end of each episode").addText(e=>e.setPlaceholder("0").setValue(String(this.settings.defaultPlaybackSettings.skipOutroSeconds||0)).onChange(async s=>{let i=parseInt(s,10);!isNaN(i)&&i>=0&&(this.settings.defaultPlaybackSettings.skipOutroSeconds=i,await this.saveSettings())}))}addCacheSection(t){t.createEl("h3",{text:"Download & Cache"}),new c.Setting(t).setName("Auto download new episodes").setDesc("Automatically download new episodes when feeds are updated").addToggle(e=>e.setValue(this.settings.autoDownload).onChange(async s=>{this.settings.autoDownload=s,await this.saveSettings()})),new c.Setting(t).setName("Maximum cached episodes").setDesc("Maximum number of episodes to keep in cache. Older episodes will be removed.").addText(e=>e.setPlaceholder("50").setValue(String(this.settings.maxCacheEpisodes)).onChange(async s=>{let i=parseInt(s,10);!isNaN(i)&&i>=0&&(this.settings.maxCacheEpisodes=i,await this.saveSettings())}))}addSyncSection(t){t.createEl("h3",{text:"Feed Sync"}),new c.Setting(t).setName("Feed update interval").setDesc("How often to check for new episodes (in minutes)").addDropdown(e=>e.addOption("15","15 minutes").addOption("30","30 minutes").addOption("60","1 hour").addOption("120","2 hours").addOption("360","6 hours").addOption("720","12 hours").addOption("1440","24 hours").setValue(String(this.settings.feedUpdateInterval)).onChange(async s=>{this.settings.feedUpdateInterval=parseInt(s,10),await this.saveSettings()}))}addNotificationSection(t){t.createEl("h3",{text:"Notifications"}),new c.Setting(t).setName("Enable notifications").setDesc("Show notifications for new episodes and playback events").addToggle(e=>e.setValue(this.settings.enableNotifications).onChange(async s=>{this.settings.enableNotifications=s,await this.saveSettings()}))}addAdvancedSection(t){t.createEl("h3",{text:"Advanced"}),new c.Setting(t).setName("Reset to defaults").setDesc("Reset all settings to their default values").addButton(e=>e.setButtonText("Reset").setWarning().onClick(async()=>{confirm("Are you sure you want to reset all settings to defaults? This cannot be undone.")&&(await this.plugin.resetSettings(),this.display(),new c.Notice("Settings reset to defaults"))})),new c.Setting(t).setName("Export settings").setDesc("Export your settings to a JSON file for backup or sharing").addButton(e=>e.setButtonText("Export").onClick(async()=>{await this.exportSettings()})),new c.Setting(t).setName("Import settings").setDesc("Import settings from a JSON file").addButton(e=>e.setButtonText("Import").onClick(async()=>{await this.importSettings()}))}async exportSettings(){try{let t=JSON.stringify(this.settings,null,2),e=new Blob([t],{type:"application/json"}),s=URL.createObjectURL(e),i=document.createElement("a");i.href=s,i.download=`podcast-player-settings-${Date.now()}.json`,i.click(),URL.revokeObjectURL(s),new c.Notice("Settings exported successfully")}catch(t){console.error("Failed to export settings:",t),new c.Notice("Failed to export settings")}}async importSettings(){let t=document.createElement("input");t.type="file",t.accept=".json",t.onchange=async e=>{var r;let i=(r=e.target.files)==null?void 0:r[0];if(i)try{let o=await i.text(),l=JSON.parse(o);if(!l.dataFolderPath||!l.defaultPlaybackSettings)throw new Error("Invalid settings file format");this.settings=l,await this.saveSettings(),this.display(),new c.Notice("Settings imported successfully")}catch(o){console.error("Failed to import settings:",o),new c.Notice("Failed to import settings: Invalid file format")}},t.click()}};var v=class extends h.Plugin{async onload(){a.info("Loading Podcast Player plugin"),this.pathManager=new m(this.app.vault,p.dataFolderPath),this.settingsStore=new y(this.app.vault,this.pathManager),await this.loadSettings(),this.addSettingTab(new S(this.app,this)),this.addRibbonIcon("podcast","Podcast Player",t=>{new h.Notice("Podcast Player - Coming Soon!")}),this.addCommand({id:"open-podcast-player",name:"Open Podcast Player",callback:()=>{new h.Notice("Podcast Player view - Coming Soon!")}}),this.addCommand({id:"subscribe-to-podcast",name:"Subscribe to Podcast",callback:()=>{new h.Notice("Subscribe to Podcast - Coming Soon!")}}),a.info("Podcast Player plugin loaded successfully")}onunload(){a.info("Unloading Podcast Player plugin")}async loadSettings(){a.methodEntry("PodcastPlayerPlugin","loadSettings");try{this.settings=await this.settingsStore.loadWithMigration(),this.pathManager.updateBasePath(this.settings.dataFolderPath),a.info("Settings loaded successfully")}catch(t){a.error("Failed to load settings, using defaults",t),this.settings={...p}}a.methodExit("PodcastPlayerPlugin","loadSettings")}async saveSettings(){a.methodEntry("PodcastPlayerPlugin","saveSettings");try{await this.settingsStore.updateSettings(this.settings),this.pathManager.updateBasePath(this.settings.dataFolderPath),a.info("Settings saved successfully")}catch(t){a.error("Failed to save settings",t),new h.Notice("Failed to save settings")}a.methodExit("PodcastPlayerPlugin","saveSettings")}async resetSettings(){a.methodEntry("PodcastPlayerPlugin","resetSettings");try{await this.settingsStore.resetToDefaults(),this.settings={...p},this.pathManager.updateBasePath(this.settings.dataFolderPath),a.info("Settings reset to defaults")}catch(t){a.error("Failed to reset settings",t),new h.Notice("Failed to reset settings")}a.methodExit("PodcastPlayerPlugin","resetSettings")}};
